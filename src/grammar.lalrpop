use crate::ast::Expression;
use crate::ast::Branch;
use crate::ast::Pattern;
use crate::ast::Typed;
use crate::ast::Per;
use crate::ast::Value;
use crate::ast::GenericTelescope;
use crate::check::expr::{check,check_infer};
use crate::check::tcm::{TCM, TCS};

grammar;

Name: String =
  {
     r"[a-zA-Z_][a-zA-Z_\d]*" => <>.to_string()
  };

Universe: Per =
  {
     <n:r"\*[\d]+"> =>
        Per::Type(u32::from_str_radix(&n[1..],10).unwrap()),
     <n:r"\*"> => Per::Type(0),
  };

Variable: Per =
  {
     <n:Name> => Per::Var(n),
  };

Vars: Pattern =
  {  <n:Name> => Pattern::Var(n),
     <n:Name> <v:Vars> => Pattern::Pair(Box::new(Pattern::Var(n)),Box::new(v)),
  };

Telescope: Vec<(Pattern,Expression)> =
  {  "(" <v:Vars> <m:":"> <t:Expr> ")" => vec![(v,t)],
     "(" <v:Vars> <m:":"> <t:Expr> ")" <x:Telescope> =>
         { let mut r = x.clone(); r.append(&mut vec![(v,t)]); r }
  };

Unit:        Per = { <l:"("> <e:Expr> <r:")"> => e, };
Lambda:      Per = { "λ" "(" <v:Vars> <m:":"> <t:Expr> ")" <c:","> <e:RExpr> => Per::Lambda(v,None,Box::new(e)), };
Pi:          Per = { "Π" "(" <v:Vars> <m:":"> <t:Expr> ")" <c:","> <e:RExpr> => Per::Pi(Typed::new(v,t), Box::new(e)), };
Sigma:       Per = { "Σ" "(" <v:Vars> <m:":"> <t:Expr> ")" <c:","> <e:RExpr> => Per::Sigma(Typed::new(v,t), Box::new(e)), };
RExpr:       Per = { Variable, Universe, Unit, Lambda, Pi, Sigma, };
Application: Per = { <l:Expr> <r:RExpr> => Per::Application(Box::new(l),Box::new(r)), };
pub Expr:    Per = { RExpr, Application };
